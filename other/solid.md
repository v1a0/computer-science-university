# SOLID

5 принципов

## Принципы 

- [ S ] Single Responsibility principle 
- [ O ] Open-Close principle
- [ L ] Liskov Substitution principle
- [ I ] Interface Segregation principle
- [ D ] Dependency Inversion principle




## Соблюдение гарантирует:

- Расширяемость/поддержка кода =>меньшие затраты
- Увеличивает читаемость кода 
- Упрощает поиск ошибок


# SRP - Single Responsibility principle

Через конкретный класс в процессе разработки должна проходить только одна ось изменений 
(класс должен меняться только по одной причине). 
Поля и методы должны относиться только к конкретному предназначению всего класса. Отвечает только за свои дела.

```
WRONG:
    
    Class
    +-------------+
    |  DateTime   |
    |      +      |
    | Temperature |
    +-------------+
    
    
RIGHT:
    
    Class                Class
    +-------------+      +----------------------+
    |  DateTime   | -----|                      |
    +-------------+      |                      |
                         |                      |
    Class                | DateTime-Temperature |
    +-------------+      |                      |
    | Temperature |------|                      |
    +-------------+      +----------------------+
```

God object - антипаттерн объектно-ориентированного программирования, описывающий объект, 
который хранит в себе «слишком много» или делает «слишком много»




# OCP - Open-Closed principle

Программные сущности (модули, функции и пр.) должны быть открыты для расширения, но закрыты для изменения.

Любой блок кода должен быть "открыт" для того, чтобы в него можно было добавить дополнительную функциональность.

## Принципы:

1. Расширение доступно только по принципу наследования от старшего класса.
2. Клиентский код должен зависть от интерфейса, который НЕИЗМЕННЫЙ!

```

    +-------------+      +-----------+
    |   Client    |----->| Interface |
    +-------------+      +-----------+
                            |    |
        +-------------+     |    |      +-------------+       
        |  Old Code   |<----+    +----->|  New Code   |
        +-------------^                 +-------v-----+
                      |                         |       
                      +--<---------<--------<---+                                                             
```

В чем смысл:
- Если прошлая функциональность не была изменена, в ней не появится новых багов => не нужно проводить полное регрессионное тестирование всего кода
- Исключения bugfix!



# LSP - Liskov Substitution principle

Функции которые используют базовые типы должны иметь возможность использовать подтипы базового типа не зная об этом.

Если есть код в который приходит базовый класс (parent), то в этот же код без каких либо исключений (exceptions) должен 
входить любой его наследник. Если наследник ломает код, то принцип нарушен.

> Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T.

Поведение наследующих классов не должно противоречит поведению заданному базовым классом.

Подкласс не должен требовать от вызывающего кода больше чем базовый класс, и не должен предоставлять вызывающему коду 
меньше чем базовый класс.


```python
class ParentDB:

    def get_user(self, u_id: int):
        """
        Returns user
        """
        data = ...
        return RealData(data)
        
    def add_user(self, u_id: int, username: str):
        """
        Returns user
        """
        ORM.add_user(u_id, username)
    
# WRONG
class ChildDB(ParentDB):

    def get_user(self, u_id: int, super_new_arg: bool):
        return None
        
    def add_user(self, u_id: int, username: str):
        raise NotImplemented

# RIGHT
class AnotherChildDB(ParentDB):

    def get_user(self, u_id: int, username: str = None):
        if username is None:
            data = super().get_user(u_id)
        else:
            data = ...
        return RealData(data)
        
    def add_user(self, u_id: int, username: str):
        super().get_user(u_id)
```

# Пример реально проблемы

```python
class Rectangular:
    def __init__(self, a: int, b: int):
        self.a = a
        self.b = b
    
    def set_a(self, val: int):
        self.a = val

    def set_b(self, val: int):
        self.b = val

class Square(Rectangular):
    def __init__(self, a: int):
        super().__init__(a, a)
    
    @property
    def b(self):
        return self.a
        
    def set_a(self, val: int):
        self.a = val

    def set_b(self, val: int):
        raise NotImplemented
```



# ISP - Interface Segregation principle

Много интерфейсов предназначенных для клиента — лучше, чем один принцип общего предназначения.

Клиенты не должны зависеть от методов, которые они не используют, 
т.е. если какой-то метод интерфейса не используется клиентом,
то изменение этого метода не должно приводить к необходимости изменений в клиентский код.

```

Class                  Interface
+-----------+          +-----------+
|     X     |----------|     X     |
+-----------+          +-----------+
                         | | | | |
                         | | | | +-----< Сlient_1
                         | | | +-------< Сlient_1, Сlient_2
                         | | +---------< Сlient_2
                         | +-----------< Сlient_3
                         +-------------< Сlient_3

Ну ты понял, нужно чтобы было много разных интерфейсов для разных клиентов, а не 1 большой
```

### Для чего:

- Безопаснее, дает клиентам только те возможности, что им нужны
- Интерфейс должен являться принадлежностью КЛИЕНТА, а поэтому клиент (, а не сервер) определяет интерфейс. Backend must to, так сказать.
- Чем проще и минималистичнее интерфейс, тема менее ресурсоёмкое является его реализация в новых классах и тем меньше причин его модификации (SRP)




# Dependency Inversion principle

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

Абстракции не должны зависеть от абстракций. Детали должны зависеть от абстракций.

Использовать классы рекомендуется исключительно через интерфейсы. Позволяет в любое место системы встроить дополнительный функционал.

